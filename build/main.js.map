{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["/*\n * Created with @iobroker/create-adapter v2.3.0\n */\n\n// The adapter-core module gives you access to the core ioBroker functions\n// you need to create an adapter\nimport * as utils from '@iobroker/adapter-core';\nimport {MeterDefinition, MeterInfoCollection, MeterState} from './lib/typedef';\nimport Calculator from './calculator';\nimport Round from './round';\n\n// Load your modules here, e.g.:\n// import * as fs from \"fs\";\n\nclass MeterStatistics extends utils.Adapter {\n\n    private unloaded = false;\n\n    private pendingPromises: Array<Promise<any>> = [];\n\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({\n            ...options,\n            name: 'meter-statistics',\n        });\n        this.on('ready', this.onReady.bind(this));\n        this.on('unload', this.onUnload.bind(this));\n    }\n\n    /**\n     * Is called when databases are connected and adapter received configuration.\n     */\n    private async onReady(): Promise<void> {\n\n        await this.assertObjectsExist();\n\n        const meterStates = await this.getMeterStates();\n\n        const calculator = new Calculator(this.config);\n\n        const meterInfos = calculator.calculateMeterInfos(meterStates);\n\n        this.writeMeterInfos(meterInfos);\n\n        this.end();\n    }\n\n    private writeMeterInfos(meterInfos: MeterInfoCollection): void {\n        for (const meterName in meterInfos) {\n            const meterInfo = meterInfos[meterName];\n\n            this.writeState(`meters.${meterName}.balance`,                   Round.costs(meterInfo.balance));\n            this.writeState(`meters.${meterName}.consumptionAverage`,        Round.consumption(meterInfo.consumptionAverage));\n            this.writeState(`meters.${meterName}.consumptionPredictedTotal`, Round.consumption(meterInfo.consumptionPredictedTotal));\n            this.writeState(`meters.${meterName}.consumptionTotal`,          Round.consumption(meterInfo.consumptionTotal));\n            this.writeState(`meters.${meterName}.costs`,                     Round.costs(meterInfo.costs));\n            this.writeState(`meters.${meterName}.paid`,                      Round.costs(meterInfo.paid));\n            this.writeState(`meters.${meterName}.recommendedPayment`,        Round.costs(meterInfo.recommendedPayment));\n        }\n    }\n\n\n    private writeState(id: string, value: any): void {\n        const promise = this.setStateAsync(id, {val: value, ack: false});\n        this.pendingPromises.push(promise);\n    }\n\n    private getNumericStateValue(state: null|undefined|ioBroker.State, onErrorMessage: string): number {\n        const stateValue = state?.val;\n        if (typeof stateValue === 'number') {\n            return stateValue;\n        }\n        throw new Error(onErrorMessage);\n    }\n\n    private async getMeterStates(): Promise<MeterState[]> {\n\n        const meterStates = [];\n\n        for (const meter of this.config.meters) {\n            meterStates.push(await this.getMeterState(meter));\n        }\n\n        return meterStates;\n    }\n\n    private async getMeterState(meter: MeterDefinition): Promise<MeterState> {\n\n        const meterName = meter.alias;\n        const currentValueState = await this.getForeignStateAsync(meter.objectId);\n        const currentValue = this.getNumericStateValue(\n            currentValueState,\n            `Could not read meter \"${meterName}\" with id: ${meter.objectId}`\n        ) || 0;\n\n        const startValueState = await this.getStateAsync(`configuration.${meterName}.startValue`);\n        let startValueDateTime: Date|null = null;\n        if (!startValueState) {\n            await this.setStateAsync(`configuration.${meterName}.startValue`, {val: currentValue, ack: true});\n            startValueDateTime = new Date(Round.precise(currentValueState?.ts || Date.now(), -3));\n            await this.setStateAsync(`configuration.${meterName}.readingDateTime`, {val: startValueDateTime.toISOString(), ack: true});\n        }\n        const startValue = this.getNumericStateValue(\n            startValueState || await this.getStateAsync(`configuration.${meterName}.startValue`),\n            `Could not read start value for meter \"${meterName}\".`\n        );\n        if (!startValueDateTime) {\n            const startValueDateTimeValue = (await this.getStateAsync(`configuration.${meterName}.readingDateTime`))?.val;\n            if (typeof startValueDateTimeValue === 'string') {\n                try {\n                    startValueDateTime = new Date(Date.parse(startValueDateTimeValue));\n                } catch (e) {}\n            }\n        }\n\n        return {\n            meter,\n            currentValue,\n            startValue,\n            startValueDateTime,\n            consumption: currentValue - startValue,\n        };\n    }\n\n    private assertObjectsExist(): Promise<any> {\n        const promises = [];\n\n        for (const meter of this.config.meters) {\n            promises.push(...this.assertMeterObjectsExist(meter.alias));\n        }\n        promises.push(...this.assertMeterObjectsExist(this.config.summaryName, false));\n\n        return Promise.allSettled(promises);\n    }\n\n    private assertMeterObjectsExist(meterName: string, hasStartValue = true): ioBroker.SetObjectPromise[] {\n        const promises = [];\n\n        promises.push(this.setObjectNotExistsAsync(`configuration.${meterName}`, {\n            type: 'device',\n            common: {\n                name: `configuration.${meterName}`,\n                icon: `/icons/${hasStartValue ? 'device' : 'summary'}-icon.svg`,\n            },\n            native: {},\n        }));\n\n        if (hasStartValue) {\n            promises.push(this.setObjectNotExistsAsync(`configuration.${meterName}.startValue`, {\n                type: 'state',\n                common: {\n                    name: 'Start value',\n                    type: 'number',\n                    role: 'state',\n                    read: true,\n                    write: true,\n                    unit: this.config.meterUnit,\n                },\n                native: {\n                },\n            }));\n            promises.push(this.setObjectNotExistsAsync(`configuration.${meterName}.readingDateTime`, {\n                type: 'state',\n                common: {\n                    name: 'Timestamp of reading start value',\n                    desc: 'ONLY INFORMATION: Does not affect any calculation yet.',\n                    type: 'string',\n                    role: 'state',\n                    read: true,\n                    write: true,\n                },\n                native: {},\n            }));\n        }\n        promises.push(this.setObjectNotExistsAsync(`meters.${meterName}.consumptionAverage`, {\n            type: 'state',\n            common: {\n                name: 'Average consumption in period',\n                type: 'number',\n                role: 'state',\n                read: true,\n                write: false,\n                unit: this.config.meterUnit,\n            },\n            native: {},\n        }));\n        promises.push(this.setObjectNotExistsAsync(`meters.${meterName}.consumptionTotal`, {\n            type: 'state',\n            common: {\n                name: 'Total consumption in period',\n                type: 'number',\n                role: 'state',\n                read: true,\n                write: false,\n                unit: this.config.meterUnit,\n            },\n            native: {},\n        }));\n        promises.push(this.setObjectNotExistsAsync(`meters.${meterName}.consumptionPredictedTotal`, {\n            type: 'state',\n            common: {\n                name: 'Total predicted consumption in period',\n                type: 'number',\n                role: 'state',\n                read: true,\n                write: false,\n                unit: this.config.meterUnit,\n            },\n            native: {},\n        }));\n        promises.push(this.setObjectNotExistsAsync(`meters.${meterName}.costs`, {\n            type: 'state',\n            common: {\n                name: 'Total costs',\n                type: 'number',\n                role: 'state',\n                read: true,\n                write: false,\n                unit: this.config.paymentUnit,\n            },\n            native: {},\n        }));\n        promises.push(this.setObjectNotExistsAsync(`meters.${meterName}.paid`, {\n            type: 'state',\n            common: {\n                name: 'Total paid value',\n                type: 'number',\n                role: 'state',\n                read: true,\n                write: false,\n                unit: this.config.paymentUnit,\n            },\n            native: {},\n        }));\n        promises.push(this.setObjectNotExistsAsync(`meters.${meterName}.balance`, {\n            type: 'state',\n            common: {\n                name: 'Current balance',\n                type: 'number',\n                role: 'state',\n                read: true,\n                write: false,\n                unit: this.config.paymentUnit,\n            },\n            native: {},\n        }));\n        promises.push(this.setObjectNotExistsAsync(`meters.${meterName}.recommendedPayment`, {\n            type: 'state',\n            common: {\n                name: 'Recommended payment per payment interval',\n                type: 'number',\n                role: 'state',\n                read: true,\n                write: false,\n                unit: this.config.paymentUnit,\n            },\n            native: {},\n        }));\n\n        return promises;\n    }\n\n    end(): void {\n        if (this.unloaded) return;\n        Promise.allSettled(this.pendingPromises).finally(() => {\n            if (this.stop) {\n                this.stop();\n            }\n        });\n    }\n\n    /**\n     * Is called when adapter shuts down - callback has to be called under any circumstances!\n     */\n    private onUnload(callback: () => void): void {\n        this.unloaded = true;\n        try {\n            // Here you must clear all timeouts or intervals that may still be active\n            callback();\n        } catch (e) {\n            callback();\n        }\n    }\n\n}\n\nif (require.main !== module) {\n    // Export the constructor in compact mode\n    module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new MeterStatistics(options);\n} else {\n    // otherwise start the instance directly\n    (() => new MeterStatistics())();\n}\n"],
  "mappings": "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",
  "names": ["Calculator", "Round"]
}
